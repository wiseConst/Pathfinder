#version 460

#extension GL_GOOGLE_include_directive : require
#include "Include/Globals.h"
#include "Include/Culling.h"

layout(local_size_x = MESHLET_LOCAL_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

struct DrawMeshTasksIndirectCommand
{
    uint32_t groupCountX;
    uint32_t groupCountY;
    uint32_t groupCountZ;
};

#ifdef __PFR_RENDER_OPAQUE_OBJECTS_

layout(buffer_reference, buffer_reference_align = 4, scalar) buffer DrawBufferOpaque
{
    uint32_t Count;
    DrawMeshTasksIndirectCommand Commands[];
} s_DrawBufferOpaqueBDA;

#endif

#ifdef __PFR_RENDER_TRANSPARENT_OBJECTS_

layout(buffer_reference, buffer_reference_align = 4, scalar) buffer DrawBufferTransparent
{
    uint32_t Count;
    DrawMeshTasksIndirectCommand Commands[];
} s_DrawBufferTransparentBDA;

#endif

void main()
{
	const uint32_t gID = gl_GlobalInvocationID.x;
	if (gID >= u_PC.data0.x) return; // contains Opaque/Transparent object count.

    #ifdef __PFR_RENDER_OPAQUE_OBJECTS_
      MeshData md = s_GlobalMeshDataBufferOpaque.MeshesData[gID];
    #endif
     
    #ifdef __PFR_RENDER_TRANSPARENT_OBJECTS_
      MeshData md = s_GlobalMeshDataBufferTransparent.MeshesData[gID];
    #endif

    Sphere sphere;
    sphere.Center = RotateByQuat(md.sphere.Center * md.scale, md.orientation) + md.translation;
    sphere.Radius = md.sphere.Radius * max(max(md.scale.x, md.scale.y), md.scale.z);
    if(SphereInsideFrustum(sphere, CameraData(u_PC.CameraDataBuffer).ViewFrustum))
    {
         #ifdef __PFR_RENDER_OPAQUE_OBJECTS_
                const uint32_t index = atomicAdd(DrawBufferOpaque(u_PC.addr0).Count, 1);
                DrawBufferOpaque(u_PC.addr0).Commands[index].groupCountX = DivideToNextMultiple(s_GlobalMeshletBuffers[md.meshletBufferIndex].meshlets.length(), MESHLET_LOCAL_GROUP_SIZE);
                DrawBufferOpaque(u_PC.addr0).Commands[index].groupCountY = 1;
                DrawBufferOpaque(u_PC.addr0).Commands[index].groupCountZ = 1;
    
                CulledMeshIDBufferOpaque(u_PC.addr1).CulledMeshIDs[index] = gID;
         #endif

         #ifdef __PFR_RENDER_TRANSPARENT_OBJECTS_    
                const uint32_t index = atomicAdd(DrawBufferTransparent(u_PC.addr0).Count, 1);
                DrawBufferTransparent(u_PC.addr0).Commands[index].groupCountX = DivideToNextMultiple(s_GlobalMeshletBuffers[md.meshletBufferIndex].meshlets.length(), MESHLET_LOCAL_GROUP_SIZE);
                DrawBufferTransparent(u_PC.addr0).Commands[index].groupCountY = 1;
                DrawBufferTransparent(u_PC.addr0).Commands[index].groupCountZ = 1;
               
                CulledMeshIDBufferTransparent(u_PC.addr1).CulledMeshIDs[index] = gID;
         #endif
    }

    barrier();

    if(gl_LocalInvocationID.x == 0)
    {
         #ifdef __PFR_RENDER_OPAQUE_OBJECTS_
            if(DrawBufferOpaque(u_PC.addr0).Count < u_PC.data0.x)
            {
                 CulledMeshIDBufferOpaque(u_PC.addr1).CulledMeshIDs[DrawBufferOpaque(u_PC.addr0).Count] = s_INVALID_CULLED_OBJECT_INDEX;
            }
         #endif

         #ifdef __PFR_RENDER_TRANSPARENT_OBJECTS_
            if(DrawBufferTransparent(u_PC.addr0).Count < u_PC.data0.x)
            {
                 CulledMeshIDBufferTransparent(u_PC.addr1).CulledMeshIDs[DrawBufferTransparent(u_PC.addr0).Count] = s_INVALID_CULLED_OBJECT_INDEX;
            }
         #endif
    }
}