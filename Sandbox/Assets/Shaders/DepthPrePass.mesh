#version 460

#extension GL_EXT_mesh_shader : require

#extension GL_GOOGLE_include_directive : require
#include "Include/Globals.h"
#include "Include/MeshletTaskPayload.glslh"

layout(local_size_x = MESHLET_LOCAL_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = MAX_MESHLET_VERTEX_COUNT, max_primitives = MAX_MESHLET_TRIANGLE_COUNT) out;

void main()
{
    uint32_t i = 0; // reusable var
    const uint32_t mi = tp_TaskData.baseMeshletID + uint32_t(tp_TaskData.meshlets[gl_WorkGroupID.x]);
    const uint32_t ti = gl_LocalInvocationID.x;

    const uint32_t primitiveCount = s_GlobalMeshletBuffers[u_PC.MeshletBufferIndex].meshlets[mi].triangleCount;
    const uint32_t vertexCount = s_GlobalMeshletBuffers[u_PC.MeshletBufferIndex].meshlets[mi].vertexCount;
    // This call will reserve output memory for storing vertex and primitive attributes (other than the vertex position). 
    // Requesting memory early helps hiding the latency required for memory allocation in the geometry engine.
    if (ti == 0) 
    {
        SetMeshOutputsEXT(vertexCount, primitiveCount);
    }

    const mat4 mvp = u_GlobalCameraData.ViewProjection * u_PC.Transform;
    const uint32_t vertexOffset = s_GlobalMeshletBuffers[u_PC.MeshletBufferIndex].meshlets[mi].vertexOffset;
    for(i = ti; i < vertexCount; i += MESHLET_LOCAL_GROUP_SIZE)
    {
        const uint32_t vi = s_GlobalMeshletVerticesBuffers[u_PC.MeshletVerticesBufferIndex].vertices[vertexOffset + i];

        gl_MeshVerticesEXT[i].gl_Position = mvp * vec4(s_GlobalVertexPosBuffers[u_PC.VertexPosBufferIndex].Positions[vi].Position, 1.0);
    }

    const uint32_t triangleOffset = s_GlobalMeshletBuffers[u_PC.MeshletBufferIndex].meshlets[mi].triangleOffset;
    for(i = ti; i < primitiveCount; i += MESHLET_LOCAL_GROUP_SIZE)
    {
        gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
            s_GlobalMeshletTrianglesBuffers[u_PC.MeshletTrianglesBufferIndex].triangles[triangleOffset + 3 * i + 0], 
            s_GlobalMeshletTrianglesBuffers[u_PC.MeshletTrianglesBufferIndex].triangles[triangleOffset + 3 * i + 1], 
            s_GlobalMeshletTrianglesBuffers[u_PC.MeshletTrianglesBufferIndex].triangles[triangleOffset + 3 * i + 2]);
    }
}