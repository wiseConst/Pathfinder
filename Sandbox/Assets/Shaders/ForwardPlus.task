#version 460

#extension GL_EXT_mesh_shader : require

#extension GL_GOOGLE_include_directive : require
#include "Include/Globals.h"
#include "Include/MeshletTaskPayload.glslh"
#include "Include/Culling.h"

layout(local_size_x = MESHLET_LOCAL_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

shared uint32_t passedMeshletCount;

layout(set = LAST_BINDLESS_SET + 1, binding = 0, scalar) readonly buffer CulledMeshIDBufferOpaque
{
    uint32_t CulledMeshIDs[];
} s_CulledMeshIDBufferOpaque;

layout(set = LAST_BINDLESS_SET + 1, binding = 1, scalar) readonly buffer CulledMeshIDBufferTransparent
{
    uint32_t CulledMeshIDs[];
} s_CulledMeshIDBufferTransparent;

void main()
{
    const uint32_t mi = gl_WorkGroupID.x;
    const uint32_t lid = gl_LocalInvocationID.x;

    if(lid == 0) 
    {
        passedMeshletCount = 0;
        tp_TaskData.baseMeshletID = gl_WorkGroupID.x * MESHLET_LOCAL_GROUP_SIZE;
    }

    MeshData md;
    if(u_PC.MaterialBufferIndex == 0) {
        if(s_CulledMeshIDBufferOpaque.CulledMeshIDs[gl_DrawID] == s_INVALID_CULLED_OBJECT_INDEX) return;
        md = s_GlobalMeshDataBufferOpaque.MeshesData[s_CulledMeshIDBufferOpaque.CulledMeshIDs[gl_DrawID]];
    }
    else {
        if(s_CulledMeshIDBufferTransparent.CulledMeshIDs[gl_DrawID] == s_INVALID_CULLED_OBJECT_INDEX) return;
        md = s_GlobalMeshDataBufferTransparent.MeshesData[s_CulledMeshIDBufferTransparent.CulledMeshIDs[gl_DrawID]];
    }

    barrier();

    const Meshlet meshlet = s_GlobalMeshletBuffers[md.meshletBufferIndex].meshlets[tp_TaskData.baseMeshletID + lid];
    const vec3 coneApex = RotateByQuat(vec3(meshlet.coneApex[0], meshlet.coneApex[1], meshlet.coneApex[2]), md.orientation) * md.scale + md.translation;
    const vec3 coneAxis = RotateByQuat(vec3(meshlet.coneAxis[0], meshlet.coneAxis[1], meshlet.coneAxis[2]), md.orientation);

    const float maxScale = max(max(md.scale.x, md.scale.y), md.scale.z);
    float scaledRadius = meshlet.radius * maxScale;
    if(maxScale != 1.0f) scaledRadius *= .5f;

    Sphere sphere;
    sphere.Center = RotateByQuat(vec3(meshlet.center[0], meshlet.center[1], meshlet.center[2]), md.orientation) * md.scale + md.translation;
    sphere.Radius = scaledRadius;

    if (!ConeCull(u_PC.CameraDataBuffer.Position, coneApex, coneAxis, meshlet.coneCutoff) && SphereInsideFrustum(sphere, u_PC.CameraDataBuffer.ViewFrustum))
    {
       const uint32_t index = atomicAdd(passedMeshletCount, 1);
       tp_TaskData.meshlets[index] = uint8_t(lid);
    }

    barrier();
    
    if (lid == 0 && passedMeshletCount != 0)
    {
        EmitMeshTasksEXT(passedMeshletCount, 1, 1);
    }
}