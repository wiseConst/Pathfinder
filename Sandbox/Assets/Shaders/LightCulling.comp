#version 460

#extension GL_GOOGLE_include_directive : require
#include "Assets/Shaders/Include/Globals.h" // needed for camera matrices

layout(local_size_x = LIGHT_CULLING_TILE_SIZE, local_size_y = LIGHT_CULLING_TILE_SIZE, local_size_z = 1) in;

// TODO: Improve
// https://www.3dgep.com/forward-plus/#Light_Culling
// https://wickedengine.net/2018/01/10/optimizing-tile-based-light-culling/
// https://rashmatash.github.io/posts/2023-05-19-light-culling-in-primal-engine.html
// https://iquilezles.org/articles/frustumcorrect/
// https://www.aortiz.me/2018/12/21/CG.html#part-1
// https://www.3dgep.com/wp-content/uploads/2017/07/3910539_Jeremiah_van_Oosten_Volume_Tiled_Forward_Shading.pdf

layout(set = LAST_BINDLESS_SET + 1, binding = 0) uniform sampler2D u_DepthTex;
layout(set = LAST_BINDLESS_SET + 1, binding = 1, scalar) writeonly buffer VisiblePointLightIndicesBuffer
{
    uint32_t indices[];
} s_VisiblePointLightIndicesBuffer;
layout(set = LAST_BINDLESS_SET + 1, binding = 2, scalar) writeonly buffer VisibleSpotLightIndicesBuffer
{
    uint32_t indices[];
} s_VisibleSpotLightIndicesBuffer;

// NOTE: Great explanation of why it is like that: https://www.youtube.com/watch?v=4p-E_31XOPM
// Check to see if a sphere is fully behind (inside the negative halfspace of) a plane. (behind normal of the plane)
// Source: Real-time collision detection, Christer Ericson (2005)
bool SphereInsidePlane( Sphere sphere, Plane plane )
{
    return dot( plane.Normal, sphere.Center ) - plane.Distance + sphere.Radius <= 0.0;
}

bool SphereInsideFrustum( Sphere sphere, Frustum frustum, float zNear, float zFar )
{
    // First check depth(behind the far plane of in front of near)
  //  if ( sphere.Center.z - sphere.Radius > zNear || sphere.Center.z + sphere.Radius < zFar ) return false;
    
//    for ( int i = 0; i < 4; i++ )
//        if ( SphereInsidePlane( sphere, frustum.Planes[i] ) ) return false;
//
//    return true;
   
   // TODO: Fix near/far plane check
    // Better to just unroll:
   bool result = true;
  // result = ((sphere.Center.z + sphere.Radius < zNear || sphere.Center.z - sphere.Radius > zFar) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[0]) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[1]) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[2]) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[3]) ? false : result);

   return result;
}

struct Cone
{
    vec3 Tip;
    float Height;
    vec3 Direction;
    float Radius;
};

// Check to see if a point is fully behind (inside the negative halfspace of) a plane.
bool PointInsidePlane(vec3 p, Plane plane)
{
    return dot(plane.Normal, p) - plane.Distance < 0;
}

bool ConeInsidePlane(Cone cone, Plane plane)
{
    // Compute the farthest point on the end of the cone to the positive space of the plane.
    const vec3 m = cross(cross(plane.Normal, cone.Direction), cone.Direction);
    const vec3 Q = cone.Tip + cone.Height * cone.Direction - cone.Radius * m;

    // The cone is in the negative halfspace of the plane if both
    // the tip of the cone and the farthest point on the end of the cone to the 
    // positive halfspace of the plane are both inside the negative halfspace 
    // of the plane.
    return PointInsidePlane(cone.Tip, plane) && PointInsidePlane(Q, plane);
}

bool ConeInsideFrustum(Cone cone, Frustum frustum, float zNear, float zFar)
{
    // NOTE: View space, facing towards -Z
    const Plane nearPlane = {vec3(0, 0, -1), -zNear};
    const Plane farPlane = {vec3(0, 0, 1), zFar};

    if(ConeInsidePlane(cone, nearPlane) || ConeInsidePlane(cone, farPlane)) return false;

    for(uint i = 0; i < 4; ++i)
    {
        if(ConeInsidePlane(cone, frustum.Planes[i])) return false;
    }

    return true;
}

shared Frustum GroupFrustum;
shared uint uMinDepth;
shared uint uMaxDepth;
shared uint visiblePointLightIndices[MAX_POINT_LIGHTS];
shared uint visiblePointLightCount;
shared uint visibleSpotLightIndices[MAX_SPOT_LIGHTS];
shared uint visibleSpotLightCount;

#define FRUSTUM_IMAGE_DEBUG 0
#define HEATMAP_IMAGE_DEBUG 1

#if HEATMAP_IMAGE_DEBUG
// From: https://github.com/turanszkij/WickedEngine/blob/8d89e305d0fc015d351e27b9bdb0fe8cea37dcc8/WickedEngine/shaders/lightCullingCS.hlsl#L269
vec4 Heatmap(uint lightCount)
{
	const vec3 mapTex[] = {
		vec3(0,0,0),
		vec3(0,0,1),
		vec3(0,1,1),
		vec3(0,1,0),
		vec3(1,1,0),
		vec3(1,0,0),
	};
	const uint mapTexLen = 5;
	const uint maxHeat = 50;
	const float l = clamp(float(lightCount) / maxHeat, 0.0f, 1.0f) * mapTexLen;
	const vec3 a = mapTex[int(floor(l))];
	const vec3 b = mapTex[int(ceil(l))];
    return vec4(mix(a, b, l - floor(l)), 1.);
}
#endif

void main()
{
    if(any(greaterThan(vec2(gl_GlobalInvocationID), u_GlobalCameraData.FullResolution))) return;
    const uvec3 wgid = gl_WorkGroupID;
    const uint lti = gl_LocalInvocationIndex;

    if(lti == 0)
    {
        // -Z = -1
        vec4 screenSpace[4];
        // Top left point
        screenSpace[0] = vec4(wgid.xy * LIGHT_CULLING_TILE_SIZE, -1.0, 1.0);
        // Top right point
        screenSpace[1] = vec4(vec2(wgid.x + 1.0, wgid.y) * LIGHT_CULLING_TILE_SIZE, -1.0, 1.0);
        // Bottom left point
        screenSpace[2] = vec4(vec2(wgid.x, wgid.y + 1.0) * LIGHT_CULLING_TILE_SIZE, -1.0, 1.0);
        // Bottom right point
        screenSpace[3] = vec4(vec2(wgid.x + 1.0, wgid.y + 1.0) * LIGHT_CULLING_TILE_SIZE, -1.0, 1.0);
       
        vec3 viewSpace[4];
        for(uint i = 0; i < 4; ++i)
            viewSpace[i] = ScreenSpaceToView(screenSpace[i], u_GlobalCameraData.FullResolution).xyz;

        // View space eye position is always at the origin.
        const vec3 eyePos = vec3(0);
        GroupFrustum.Planes[0] = ComputePlane(eyePos, viewSpace[2], viewSpace[0]);
        GroupFrustum.Planes[1] = ComputePlane(eyePos, viewSpace[1], viewSpace[3]);
        GroupFrustum.Planes[2] = ComputePlane(eyePos, viewSpace[0], viewSpace[1]);
        GroupFrustum.Planes[3] = ComputePlane(eyePos, viewSpace[3], viewSpace[2]);
    
        visiblePointLightCount = 0;
        visibleSpotLightCount = 0;
        uMinDepth = 0x7F7FFFFF;
		uMaxDepth = 0;
    }

    barrier();

    const ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

#if FRUSTUM_IMAGE_DEBUG
    const uint half_tile = LIGHT_CULLING_TILE_SIZE / 2;
    vec3 frustumColor = abs(GroupFrustum.Planes[1].Normal);
    const uint gridIndex = GetLinearGridIndex(pixelCoords, u_GlobalCameraData.FullResolution.x);

    if(GetLinearGridIndex(vec2(pixelCoords.x+half_tile,pixelCoords.y), u_GlobalCameraData.FullResolution.x) == gridIndex && GetLinearGridIndex(vec2(pixelCoords.x,pixelCoords.y+half_tile),u_GlobalCameraData.FullResolution.x) == gridIndex)
    {
        frustumColor = abs(GroupFrustum.Planes[0].Normal);
    }else if(GetLinearGridIndex(vec2(pixelCoords.x+half_tile,pixelCoords.y), u_GlobalCameraData.FullResolution.x) != gridIndex && GetLinearGridIndex(vec2(pixelCoords.x,pixelCoords.y+half_tile),u_GlobalCameraData.FullResolution.x) == gridIndex)
    {
        frustumColor = abs(GroupFrustum.Planes[2].Normal);
    }else if(GetLinearGridIndex(vec2(pixelCoords.x+half_tile,pixelCoords.y), u_GlobalCameraData.FullResolution.x) == gridIndex && GetLinearGridIndex(vec2(pixelCoords.x,pixelCoords.y+half_tile),u_GlobalCameraData.FullResolution.x) != gridIndex)
    {
        frustumColor = abs(GroupFrustum.Planes[3].Normal);
    }

    imageStore(u_GlobalImages_RGBA8[u_PC.AlbedoTextureIndex], pixelCoords, vec4(frustumColor,1));
 #endif

    // Linearize the depth value from depth buffer (must do this because we created it using projection)
    const vec2 UV = pixelCoords / u_GlobalCameraData.FullResolution;
    float fDepth = LinearizeDepth(texture(u_DepthTex, UV).r);
    const uint uDepth = floatBitsToUint(fDepth);

    uMinDepth = atomicMin(uMinDepth, uDepth);
    uMaxDepth = atomicMax(uMaxDepth, uDepth);

    barrier();

    const float fMinDepth = uintBitsToFloat(uMinDepth);
    const float fMaxDepth = uintBitsToFloat(uMaxDepth);

    const float minDepthVS = ScreenSpaceToView(vec4(0, 0, fMinDepth, 1), u_GlobalCameraData.FullResolution).z;
    const float maxDepthVS = ScreenSpaceToView(vec4(0, 0, fMaxDepth, 1), u_GlobalCameraData.FullResolution).z;
    const float nearClipVS = ScreenSpaceToView(vec4(0, 0, 1, 1), u_GlobalCameraData.FullResolution).z; // I use Reversed-Z, where N:1, F:0
    
    Plane minPlane = { vec3(0, 0, -1), -minDepthVS};
    for(uint i = lti; i < u_Lights.PointLightCount; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
      if(visiblePointLightCount + 1 > u_Lights.PointLightCount) break;

      const PointLight pl = u_Lights.PointLights[i];
      const vec3 plPosVS = vec3(u_GlobalCameraData.View * vec4(pl.Position, 1));
     
     // TODO: Fix far/near plane with this:
   //  debugPrintfEXT("%lf,%lf,%lf,%lf, pos: %lf,%lf,%lf",fDepth,minDepthVS,maxDepthVS,nearClipVS,plPosVS.x,plPosVS.y,plPosVS.z);

      Sphere sphere = {plPosVS, pl.Radius * 1.2f};
      if ( SphereInsideFrustum( sphere, GroupFrustum, nearClipVS, maxDepthVS ) ) // Swap nearClip & maxDepth when far/near check for reversed z
      {
          if ( SphereInsidePlane( sphere, minPlane ) ) continue;
          
          const uint offset = atomicAdd(visiblePointLightCount, 1);
          if(offset < u_Lights.PointLightCount)
             visiblePointLightIndices[offset] = i;
      }
    }

    for(uint i = lti; i < u_Lights.SpotLightCount; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        if(visibleSpotLightCount >= u_Lights.SpotLightCount) break;

        SpotLight spl = u_Lights.SpotLights[i];
        const vec3 splPosVS = vec3(u_GlobalCameraData.View * vec4(spl.Position, 1));
        Cone cone = { splPosVS, spl.Height, spl.Direction, spl.Radius};
        if ( ConeInsideFrustum( cone, GroupFrustum, nearClipVS, maxDepthVS ) )
        {
            if ( ConeInsidePlane( cone, minPlane ) ) continue;
            
            const uint offset = atomicAdd(visibleSpotLightCount, 1);
            if(offset < u_Lights.SpotLightCount)
               visibleSpotLightIndices[offset] = i;
            
        }
    }

    barrier();

    if(lti == 0)
    { 
        const uint linearTileIndex = GetLinearGridIndex(pixelCoords, u_GlobalCameraData.FullResolution.x);

        // Handling point lights
        {
            const uint offset = linearTileIndex * MAX_POINT_LIGHTS;
            s_VisiblePointLightIndicesBuffer.indices[offset] = INVALID_LIGHT_INDEX;
            for(uint i = 0; i < visiblePointLightCount; ++i)
                s_VisiblePointLightIndicesBuffer.indices[offset + i] = visiblePointLightIndices[i];

            // NOTE: Mark end as invalid
            if(visiblePointLightCount < u_Lights.PointLightCount)
            {
                s_VisiblePointLightIndicesBuffer.indices[offset + visiblePointLightCount] = INVALID_LIGHT_INDEX;
            }
        }

        // Handling spot lights
        {
            const uint offset = linearTileIndex * MAX_SPOT_LIGHTS;
            s_VisibleSpotLightIndicesBuffer.indices[offset] = INVALID_LIGHT_INDEX;
            for(uint i = 0; i < visibleSpotLightCount; ++i)
                s_VisibleSpotLightIndicesBuffer.indices[offset + i] = visibleSpotLightIndices[i];

            // NOTE: Mark end as invalid
            if(visibleSpotLightCount < u_Lights.SpotLightCount)
            {
                s_VisibleSpotLightIndicesBuffer.indices[offset + visibleSpotLightCount] = INVALID_LIGHT_INDEX;
            }
        }
    }

#if HEATMAP_IMAGE_DEBUG
    imageStore(u_GlobalImages_RGBA8[u_PC.NormalTextureIndex], pixelCoords, Heatmap(visiblePointLightCount + visibleSpotLightCount));
#endif
}
