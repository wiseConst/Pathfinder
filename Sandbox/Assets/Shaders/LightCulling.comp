#version 460

#define SHADER_DEBUG_PRINTF 0

#extension GL_GOOGLE_include_directive : require
#include "Assets/Shaders/Include/Globals.h" // needed for camera matrices

layout(local_size_x = LIGHT_CULLING_TILE_SIZE, local_size_y = LIGHT_CULLING_TILE_SIZE, local_size_z = 1) in;

// Credits to:
// https://github.com/turanszkij/WickedEngine/blob/fa70f6d465aa7946ab497dc6ac0d685a9bce23bf/WickedEngine/shaders/lightCullingCS.hlsl#L353
// https://wickedengine.net/2018/01/10/optimizing-tile-based-light-culling/
// https://rashmatash.github.io/posts/2023-05-19-light-culling-in-primal-engine.html
// https://iquilezles.org/articles/frustumcorrect/
// https://www.aortiz.me/2018/12/21/CG.html#part-1
// https://www.3dgep.com/wp-content/uploads/2017/07/3910539_Jeremiah_van_Oosten_Volume_Tiled_Forward_Shading.pdf
// https://www.3dgep.com/forward-plus/#Light_Culling
// https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf
// https://www.humus.name/Articles/PracticalClusteredShading.pdf
// https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf

layout(constant_id = 0) const float blurRange = 1.0f;
layout(set = LAST_BINDLESS_SET + 1, binding = 0) uniform sampler2D u_DepthTex;
layout(set = LAST_BINDLESS_SET + 1, binding = 1, scalar) readonly buffer LightCullingFrustum
{
    Frustum frustums[];
} s_GridFrustumsBuffer;
layout(set = LAST_BINDLESS_SET + 1, binding = 2, scalar) writeonly buffer VisiblePointLightIndicesBuffer
{
    uint32_t indices[];
} s_VisiblePointLightIndicesBuffer;
layout(set = LAST_BINDLESS_SET + 1, binding = 3, scalar) writeonly buffer VisibleSpotLightIndicesBuffer
{
    uint32_t indices[];
} s_VisibleSpotLightIndicesBuffer;

// NOTE: Great explanation of why it is like that: https://www.youtube.com/watch?v=4p-E_31XOPM
// Check to see if a sphere is fully behind (inside the negative halfspace of) a plane. (behind normal of the plane)
// Source: Real-time collision detection, Christer Ericson (2005)
bool SphereInsidePlane( Sphere sphere, Plane plane )
{
    return dot( plane.Normal, sphere.Center ) - plane.Distance + sphere.Radius <= 0.0;
}

bool SphereInsideFrustum( Sphere sphere, Frustum frustum, float zNear, float zFar )
{
   // Better to just unroll:
   bool result = true;
   
   // First check depth(behind the far plane of in front of near)
   result = ((sphere.Center.z - sphere.Radius > zNear ||  sphere.Center.z + sphere.Radius < zFar) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[0]) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[1]) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[2]) ? false : result);
   result = (SphereInsidePlane(sphere, frustum.Planes[3]) ? false : result);

   return result;
}

bool SphereIntersectsAABB(in Sphere sphere, in AABB aabb) {
    vec3 vDelta = max(vec3(0.0), abs(aabb.Center - sphere.Center) - aabb.Extents);
    float fDistSq = dot(vDelta, vDelta);
    return fDistSq <= sphere.Radius * sphere.Radius;
}

struct Cone
{
    vec3 Tip;
    float Height;
    vec3 Direction;
    float Radius;
};

// Check to see if a point is fully behind (inside the negative halfspace of) a plane.
bool PointInsidePlane(vec3 p, Plane plane)
{
    return dot(plane.Normal, p) - plane.Distance < 0;
}

bool ConeInsidePlane(Cone cone, Plane plane)
{
    // Compute the farthest point on the end of the cone to the positive space of the plane.
    const vec3 m = cross(cross(plane.Normal, cone.Direction), cone.Direction);
    const vec3 Q = cone.Tip + cone.Height * cone.Direction - cone.Radius * m;

    // The cone is in the negative halfspace of the plane if both
    // the tip of the cone and the farthest point on the end of the cone to the 
    // positive halfspace of the plane are both inside the negative halfspace 
    // of the plane.
    return PointInsidePlane(cone.Tip, plane) && PointInsidePlane(Q, plane);
}

bool ConeInsideFrustum(Cone cone, Frustum frustum, float zNear, float zFar)
{
    // NOTE: View space, facing towards -Z
    const Plane nearPlane = {vec3(0, 0, -1), -zNear};
    const Plane farPlane = {vec3(0, 0, 1), zFar};

    if(ConeInsidePlane(cone, nearPlane) || ConeInsidePlane(cone, farPlane)) return false;

    for(uint i = 0; i < 4; ++i)
    {
        if(ConeInsidePlane(cone, frustum.Planes[i])) return false;
    }

    return true;
}

shared uint tileDepthMask;
shared Frustum groupFrustum;
shared uint uMinDepth;
shared uint uMaxDepth;
shared uint visiblePointLightIndices[MAX_POINT_LIGHTS];
shared uint visiblePointLightCount;
shared uint visibleSpotLightIndices[MAX_SPOT_LIGHTS];
shared uint visibleSpotLightCount;

#define FRUSTUM_IMAGE_DEBUG 0
#define HEATMAP_IMAGE_DEBUG 1

#if HEATMAP_IMAGE_DEBUG
vec4 Heatmap(uint lightCount)
{
	const vec3 mapTex[] = {
		vec3(0,0,0),
		vec3(0,0,1),
		vec3(0,1,1),
		vec3(0,1,0),
		vec3(1,1,0),
		vec3(1,0,0),
	};
	const uint mapTexLen = 5;
	const uint maxHeat = 50;
	const float l = clamp(float(lightCount) / maxHeat, 0.0f, 1.0f) * mapTexLen;
	const vec3 a = mapTex[int(floor(l))];
	const vec3 b = mapTex[int(ceil(l))];
    return vec4(mix(a, b, l - floor(l)), 1.);
}
#endif

 uint ConstructLightMask(in float depthRangeMin, in float depthRangeRecip, in Sphere bounds)
{
	// We create a entity mask to decide if the entity is really touching something
	// If we do an OR operation with the depth slices mask, we instantly get if the entity is contributing or not
	// we do this in view space

	const float fMin = bounds.Center.z - bounds.Radius;
	const float fMax = bounds.Center.z + bounds.Radius;
	const uint lightMaskCellindexSTART = max(0, min(31, uint(floor((fMin - depthRangeMin) * depthRangeRecip) )));
	const uint lightMaskCellindexEND = max(0, min(31, uint(floor((fMax - depthRangeMin) * depthRangeRecip) )));

	//// Unoptimized mask construction with loop:
	//// Construct mask from START to END:
	////          END         START
	////	0000000000111111111110000000000
	//uint uLightMask = 0;
	//for (uint c = __entitymaskcellindexSTART; c <= __entitymaskcellindexEND; ++c)
	//{
	//	uLightMask |= 1u << c;
	//}


	// Optimized mask construction, without loop:
	//	- First, fill full mask:
	//	1111111111111111111111111111111
	uint uLightMask = 0xFFFFFFFF;
	//	- Then Shift right with spare amount to keep mask only:
	//	0000000000000000000011111111111
	uLightMask >>= 31u - (lightMaskCellindexEND - lightMaskCellindexSTART);
	//	- Last, shift left with START amount to correct mask position:
	//	0000000000111111111110000000000
	uLightMask <<= lightMaskCellindexSTART;

	return uLightMask;
}

// flattened array index to 2D array index
uvec2 unflatten2D(uint idx, uvec2 dim)
{
	return uvec2(idx % dim.x, idx / dim.x);
}

void main()
{
    if(any(greaterThan(vec2(gl_GlobalInvocationID), u_GlobalCameraData.FullResolution))) return;
    const uvec3 wgid = gl_WorkGroupID;
    const uint lti = gl_LocalInvocationIndex;
    const ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

    if(lti == 0)
    {
        const uint linearTileIndex = GetLinearGridIndex(pixelCoords, u_GlobalCameraData.FullResolution.x);
        groupFrustum = s_GridFrustumsBuffer.frustums[linearTileIndex];
        visiblePointLightCount = 0;
        visibleSpotLightCount = 0;
        uMinDepth = 0x7f7fffff;
		uMaxDepth = 0;
        tileDepthMask = 0;
    }
    
    barrier();

#if FRUSTUM_IMAGE_DEBUG
    const uint half_tile = LIGHT_CULLING_TILE_SIZE / 2;
    vec3 frustumColor = abs(groupFrustum.Planes[1].Normal);
    const uint gridIndex = GetLinearGridIndex(pixelCoords, u_GlobalCameraData.FullResolution.x);

    if(GetLinearGridIndex(vec2(pixelCoords.x+half_tile,pixelCoords.y), u_GlobalCameraData.FullResolution.x) == gridIndex && GetLinearGridIndex(vec2(pixelCoords.x,pixelCoords.y+half_tile),u_GlobalCameraData.FullResolution.x) == gridIndex)
    {
        frustumColor = abs(groupFrustum.Planes[0].Normal);
    }else if(GetLinearGridIndex(vec2(pixelCoords.x+half_tile,pixelCoords.y), u_GlobalCameraData.FullResolution.x) != gridIndex && GetLinearGridIndex(vec2(pixelCoords.x,pixelCoords.y+half_tile),u_GlobalCameraData.FullResolution.x) == gridIndex)
    {
        frustumColor = abs(groupFrustum.Planes[2].Normal);
    }else if(GetLinearGridIndex(vec2(pixelCoords.x+half_tile,pixelCoords.y), u_GlobalCameraData.FullResolution.x) == gridIndex && GetLinearGridIndex(vec2(pixelCoords.x,pixelCoords.y+half_tile),u_GlobalCameraData.FullResolution.x) != gridIndex)
    {
        frustumColor = abs(groupFrustum.Planes[3].Normal);
    }

    imageStore(u_GlobalImages_RGBA8[u_PC.AlbedoTextureIndex], pixelCoords, vec4(frustumColor,1));
 #endif

    const vec2 UV = pixelCoords / u_GlobalCameraData.FullResolution;
    
#if 0
    // Calculate min & max depth in threadgroup / tile.
	float depthMinUnrolled = 10000000;
	float depthMaxUnrolled = -10000000;
    
    const float fDepth = texture(u_DepthTex, UV).r;

   	const vec2 texelSize = 1.f / u_GlobalCameraData.FullResolution;
    for(float x = -LIGHT_CULLING_GRANULARITY; x < LIGHT_CULLING_GRANULARITY; x += LIGHT_CULLING_GRANULARITY)
	{
		for(float y = -LIGHT_CULLING_GRANULARITY; y < LIGHT_CULLING_GRANULARITY; y += LIGHT_CULLING_GRANULARITY)
		{
			const vec2 offsetUV = vec2(x, y) * texelSize;

            const float fDepthLocal =texture(u_DepthTex, UV + offsetUV).r;

            depthMinUnrolled = min(depthMinUnrolled, fDepthLocal);
		    depthMaxUnrolled = max(depthMaxUnrolled, fDepthLocal);
		}
	}

     uMinDepth = atomicMin(uMinDepth, floatBitsToUint(depthMinUnrolled));
     uMaxDepth = atomicMax(uMaxDepth, floatBitsToUint(depthMaxUnrolled));

#else
     const float fDepth = texture(u_DepthTex, UV).r;
     const uint uDepth = floatBitsToUint(fDepth);

     // Don't include far-plane (i.e. no geometry). Reversed depth buffer
     if(uDepth!=0)
     {
        uMinDepth = atomicMin(uMinDepth, uDepth);
        uMaxDepth = atomicMax(uMaxDepth, uDepth);
     }
#endif

    barrier();

    // reversed depth buffer!
    const float fMinDepth = uintBitsToFloat(uMaxDepth);
    const float fMaxDepth = uintBitsToFloat(uMinDepth);

    // TODO: Maybe make it shared?
    AABB groupAABB; // frustum AABB around min-max depth in View Space
	// I construct an AABB around the minmax depth bounds to perform tighter culling:
	// The frustum is asymmetric so we must consider all corners!

	vec3 viewSpace[8];
	// Top left point, near
	viewSpace[0] = ScreenSpaceToView(vec4(wgid.xy * LIGHT_CULLING_TILE_SIZE, fMinDepth, 1.0f), u_GlobalCameraData.FullResolution).xyz;
	// Top right point, near
	viewSpace[1] = ScreenSpaceToView(vec4(vec2(wgid.x + 1, wgid.y) * LIGHT_CULLING_TILE_SIZE, fMinDepth, 1.0f),  u_GlobalCameraData.FullResolution).xyz;
	// Bottom left point, near
	viewSpace[2] = ScreenSpaceToView(vec4(vec2(wgid.x, wgid.y + 1) * LIGHT_CULLING_TILE_SIZE, fMinDepth, 1.0f),  u_GlobalCameraData.FullResolution).xyz;
	// Bottom right point, near
	viewSpace[3] = ScreenSpaceToView(vec4(vec2(wgid.x + 1, wgid.y + 1) * LIGHT_CULLING_TILE_SIZE, fMinDepth, 1.0f),  u_GlobalCameraData.FullResolution).xyz;

	// Top left point, far
	viewSpace[4] = ScreenSpaceToView(vec4(wgid.xy * LIGHT_CULLING_TILE_SIZE, fMaxDepth, 1.0f),  u_GlobalCameraData.FullResolution).xyz;
	// Top right point, far
	viewSpace[5] = ScreenSpaceToView(vec4(vec2(wgid.x + 1, wgid.y) * LIGHT_CULLING_TILE_SIZE, fMaxDepth, 1.0f),  u_GlobalCameraData.FullResolution).xyz;
	// Bottom left point, far
	viewSpace[6] = ScreenSpaceToView(vec4(vec2(wgid.x, wgid.y + 1) * LIGHT_CULLING_TILE_SIZE, fMaxDepth, 1.0f),  u_GlobalCameraData.FullResolution).xyz;
	// Bottom right point, far
	viewSpace[7] = ScreenSpaceToView(vec4(vec2(wgid.x + 1, wgid.y + 1) * LIGHT_CULLING_TILE_SIZE, fMaxDepth, 1.0f),  u_GlobalCameraData.FullResolution).xyz;

	vec3 minAABB = vec3(10000000);
	vec3 maxAABB = vec3(-10000000);
	for (uint i = 0; i < 8; ++i)
	{
		minAABB = min(minAABB, viewSpace[i]);
		maxAABB = max(maxAABB, viewSpace[i]);
	}
    
    // AABBfromMinMax(GroupAABB, minAABB, maxAABB);
    groupAABB.Center = (maxAABB + minAABB) * .5f;
    groupAABB.Extents = (maxAABB - groupAABB.Center);

    const float minDepthVS = ScreenSpaceToView(vec4(0, 0, fMinDepth, 1), u_GlobalCameraData.FullResolution).z;
    const float maxDepthVS = ScreenSpaceToView(vec4(0, 0, fMaxDepth, 1), u_GlobalCameraData.FullResolution).z;
    const float nearClipVS = ScreenSpaceToView(vec4(0, 0, 1, 1), u_GlobalCameraData.FullResolution).z; // I use Reversed-Z, where N:1, F:0

    // 2.5D culling
    // Divide depth range into 32 slices.
    const float depthRangeRcp = 32.0f / (maxDepthVS - minDepthVS);
    const float realDepthVS = ScreenSpaceToView(vec4(0, 0, fDepth, 1), u_GlobalCameraData.FullResolution).z;
    const uint depthMaskCellIndex = max(0, min(31, uint( floor((realDepthVS - minDepthVS) * depthRangeRcp) )));
    atomicOr(tileDepthMask, 1 << depthMaskCellIndex);

    Plane minPlane = { vec3(0, 0, -1), -minDepthVS};
    for(uint i = lti; i < u_Lights.PointLightCount && uDepth != 0; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
      if(visiblePointLightCount + 1 > u_Lights.PointLightCount) break;

      const PointLight pl = u_Lights.PointLights[i];
      const vec3 plPosVS = vec3(u_GlobalCameraData.View * vec4(pl.Position, 1));

    #if SHADER_DEBUG_PRINTF
    // if(pixelCoords.x >= u_GlobalCameraData.FullResolution.x/2 && pixelCoords.y >= u_GlobalCameraData.FullResolution.y/2)
      debugPrintfEXT("pixel:(%u,%u),%lf,%lf,%lf,%lf,%lf,%lf",pixelCoords.x,pixelCoords.y,fDepth,fMinDepth,fMaxDepth,minDepthVS,maxDepthVS,nearClipVS);
   #endif

      Sphere sphere = {plPosVS, pl.Radius};
      if ( SphereInsideFrustum( sphere, groupFrustum, nearClipVS, maxDepthVS ) )
      {
        // Replace with different shit.
        // if ( SphereInsidePlane( sphere, minPlane ) ) continue; 
        if (!SphereIntersectsAABB(sphere, groupAABB)) continue;// tighter fit than sphere-frustum culling

        // bLightContributesToGeometry
        const bool intersect2_5D = (tileDepthMask & ConstructLightMask(minDepthVS, depthRangeRcp, sphere)) > 0;
        if(intersect2_5D)
        {
          const uint offset = atomicAdd(visiblePointLightCount, 1);
          if(offset < u_Lights.PointLightCount)
             visiblePointLightIndices[offset] = i;
        }
      }
    }

    for(uint i = lti; i < u_Lights.SpotLightCount && uDepth != 0; i += LIGHT_CULLING_TILE_SIZE * LIGHT_CULLING_TILE_SIZE)
    {
        if(visibleSpotLightCount >= u_Lights.SpotLightCount) break;

        SpotLight spl = u_Lights.SpotLights[i];
        const vec3 splPosVS = vec3(u_GlobalCameraData.View * vec4(spl.Position, 1));
        const vec3 splDirVS =  vec3(u_GlobalCameraData.View * vec4(spl.Direction, 1));
        Cone cone = { splPosVS, spl.Height, splDirVS, spl.Radius};
        if ( ConeInsideFrustum( cone, groupFrustum, nearClipVS, maxDepthVS ) )
        {
            if ( ConeInsidePlane( cone, minPlane ) ) continue;
            
            const uint offset = atomicAdd(visibleSpotLightCount, 1);
            if(offset < u_Lights.SpotLightCount)
               visibleSpotLightIndices[offset] = i;
            
        }
    }
    
    barrier();

    if(lti == 0)
    { 
        const uint linearTileIndex = GetLinearGridIndex(pixelCoords, u_GlobalCameraData.FullResolution.x);

        // Handling point lights
        {   
            const uint offset = linearTileIndex * MAX_POINT_LIGHTS;
            s_VisiblePointLightIndicesBuffer.indices[offset] = INVALID_LIGHT_INDEX;
            for(uint i = 0; i < visiblePointLightCount; ++i)
                s_VisiblePointLightIndicesBuffer.indices[offset + i] = visiblePointLightIndices[i];

            // NOTE: Mark end as invalid
            if(visiblePointLightCount < u_Lights.PointLightCount)
            {
                s_VisiblePointLightIndicesBuffer.indices[offset + visiblePointLightCount] = INVALID_LIGHT_INDEX;
            }
        }

        // Handling spot lights
        {
            const uint offset = linearTileIndex * MAX_SPOT_LIGHTS;
            s_VisibleSpotLightIndicesBuffer.indices[offset] = INVALID_LIGHT_INDEX;
            for(uint i = 0; i < visibleSpotLightCount; ++i)
                s_VisibleSpotLightIndicesBuffer.indices[offset + i] = visibleSpotLightIndices[i];

            // NOTE: Mark end as invalid
            if(visibleSpotLightCount < u_Lights.SpotLightCount)
            {
                s_VisibleSpotLightIndicesBuffer.indices[offset + visibleSpotLightCount] = INVALID_LIGHT_INDEX;
            }
        }
    }

#if HEATMAP_IMAGE_DEBUG
    imageStore(u_GlobalImages_RGBA8[u_PC.StorageImageIndex], pixelCoords, Heatmap(visiblePointLightCount + visibleSpotLightCount));
#endif
}
