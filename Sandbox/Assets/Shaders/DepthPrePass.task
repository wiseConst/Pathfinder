#version 460

#extension GL_EXT_mesh_shader : require

#extension GL_GOOGLE_include_directive : require
#include "Include/Globals.h"
#include "Include/MeshletTaskPayload.glslh"
#include "Include/Culling.h"

layout(local_size_x = MESHLET_LOCAL_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

shared uint32_t passedMeshletCount;

void main()
{
    const uint32_t mi = gl_WorkGroupID.x;
    const uint32_t lid = gl_LocalInvocationID.x;

    if(lid == 0) 
    {
        passedMeshletCount = 0;
        tp_TaskData.baseMeshletID = gl_WorkGroupID.x * MESHLET_LOCAL_GROUP_SIZE;
    }

    if(CulledMeshIDBufferOpaque(u_PC.addr0).CulledMeshIDs[gl_DrawID] == s_INVALID_CULLED_OBJECT_INDEX) return;
    const MeshData md = s_GlobalMeshDataBufferOpaque.MeshesData[CulledMeshIDBufferOpaque(u_PC.addr0).CulledMeshIDs[gl_DrawID]];

    barrier();

    const Meshlet meshlet = s_GlobalMeshletBuffers[md.meshletBufferIndex].meshlets[tp_TaskData.baseMeshletID + lid];
    const vec3 coneApex = RotateByQuat(meshlet.coneApex * md.scale, md.orientation) + md.translation;
    const vec3 coneAxis = RotateByQuat(meshlet.coneAxis, md.orientation);

    Sphere sphere;
    sphere.Center = RotateByQuat(meshlet.center * md.scale, md.orientation) + md.translation;
    sphere.Radius = meshlet.radius * max(max(md.scale.x, md.scale.y), md.scale.z);

    if (!IsConeBackfacing(CameraData(u_PC.CameraDataBuffer).Position, coneApex, coneAxis, meshlet.coneCutoff, sphere.Radius) && SphereInsideFrustum(sphere, CameraData(u_PC.CameraDataBuffer).ViewFrustum))
    {
       const uint32_t index = atomicAdd(passedMeshletCount, 1);
       tp_TaskData.meshlets[index] = uint8_t(lid);
    }

    barrier();
    
    if (lid == 0 && passedMeshletCount != 0)
    {
        EmitMeshTasksEXT(passedMeshletCount, 1, 1);
    }
}